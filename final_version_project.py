# -*- coding: utf-8 -*-
"""Final_version_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hwFtR6385rKmyOlIsf51DoMyrC6BSoVY

### In this File Basic idea is merge both csv's then apply other preprocessing technique
"""

import re
import csv
import time
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

# Load CSVs into DataFrames
df1 = pd.read_csv('mega_pk_Final_data.csv')
df2 = pd.read_csv('PakLab_Final_data.csv')

appended_df = pd.concat([df1, df2], ignore_index=True, sort=False)

appended_df = appended_df.sort_values(by='Brand')
# appended_df.to_csv('Final_appended_data.csv', index=False, header=True)
appended_df

appended_df.info()

"""## More Preprocessing for all columns"""

appended_df['TouchScreen'] = (appended_df['TouchScreen'] == 'Yes').astype(int)
appended_df['Finger Print Reader'] = (appended_df['Finger Print Reader'] == 'Yes').astype(int)
appended_df['Backlit keyboard'] = (appended_df['Backlit keyboard'] == 'Yes').astype(int)
appended_df['LAN'] = (appended_df['LAN'] == 'Yes').astype(int)

"""> ## Handling Processor Genration"""

appended_df

# Corrected brand mapping dictionary
brand_mapping = {
    'acer': 1,
    'asus': 2,
    'dell': 3,
    'hp': 4,       # Use lowercase for consistency
    'lenovo': 5,
    'msi': 6,
    'microsoft': 7,
    'samsung': 8,
    'surface': 9
}

appended_df['Brand'] = appended_df['Brand'].str.strip().str.lower()  # Normalize to lowercase

appended_df['Brand'] = appended_df['Brand'].replace(brand_mapping)

appended_df['Brand'].unique()

"""> ## Handling Brand"""

appended_df['Brand'].unique()

"""> ## Handling Processor Genaration"""

appended_df['Processor Generation'].unique()

appended_df['Processor Generation'] = appended_df['Processor Generation'].str.strip()

appended_df['Processor Generation'] = appended_df['Processor Generation'].replace({'AMD':12,
                                                                                   'X Elite':14,
                                                                                   'Unknown':0,
                                                                                   })



appended_df['Processor Generation'].unique()

print(appended_df['Processor Generation'].value_counts())
print(appended_df['Processor Generation'].isna().sum())

appended_df['Processor Generation'] = appended_df['Processor Generation'].str.extract(r'(\d+)')
print(appended_df['Processor Generation'].isna().sum())
appended_df['Processor Generation'] = appended_df['Processor Generation'].fillna(0)
print(appended_df['Processor Generation'].isna().sum())
print(appended_df['Processor Generation'].value_counts())

appended_df['Processor Generation'].unique()

appended_df

"""> ## Handling Processor Type"""

appended_df['Processor Type'].unique()

pattern = r'(AMD|Core|Intel|Snapdragon)'
appended_df['Processor Type'] = appended_df['Processor Type'].str.extract(pattern,expand=False)

appended_df['Processor Type'].unique()

appended_df['Processor Type'] = appended_df['Processor Type'].str.replace('Core','Intel')
appended_df['Processor Type'].unique()

appended_df['Processor Type'] = appended_df['Processor Type'].replace({'Intel':'0',
                                                                           'AMD':'1',
                                                                           'Snapdragon':'2'},regex=True)

appended_df

"""> ## Handling Graphics Series"""

appended_df['Graphic Series'].unique()

appended_df['Graphic Series'].value_counts()

appended_df['Graphic Series'] =appended_df['Graphic Series'].str.strip()
# Define a function to extract graphic brand and memory
def extract_graphics_info(graphic):
    # Initialize default values
    brand = 'Unknown'
    memory = ''

    # Mapping for brand identification
    if 'NVIDIA' in graphic or 'Nvidia' in graphic:
        brand = 'NVIDIA'
    elif 'AMD' in graphic:
        brand = 'AMD'
    elif 'Intel' in graphic:
        brand = 'Intel'
    elif 'Qualcomm' in graphic:
        brand = 'Qualcomm'
    elif 'RTX' in graphic:
        brand = 'RTX'


    # Extract memory using regex (e.g., "6-GB", "GDDR6")
    memory_match = re.search(r'(\d-GB+|\d+\s*|\d+\s*|\d+|\d-?GB)', graphic)
    if memory_match:
        memory = memory_match.group(0).strip()

    return pd.Series([brand, memory])

appended_df[['Graphic Brand', 'Graphic Memory']] = appended_df['Graphic Series'].apply(extract_graphics_info).apply(pd.Series)
# Insert 'Graphic Brand' at index 1 (after 'Graphic Series')
appended_df.insert(7, 'Graphic Brand', appended_df.pop('Graphic Brand'))

# Insert 'Graphic Memory' at index 2 (after 'Graphic Brand')
appended_df.insert(8, 'Graphic Memory', appended_df.pop('Graphic Memory'))

appended_df
print(appended_df['Graphic Brand'].unique())
print(appended_df['Graphic Memory'].unique())



appended_df['Graphic Memory'] =  appended_df['Graphic Memory'].replace({'6-GB':'6',
                                                                        '':'0'})
appended_df['Graphic Memory'].unique()

appended_df['Graphic Memory'].value_counts()

appended_df

appended_df.drop(columns=['Graphic Series'],inplace=True)

"""> ## __Graphic Brand__"""

appended_df['Graphic Brand'].unique()

appended_df['Graphic Brand'].value_counts()

appended_df['Graphic Brand'] = appended_df['Graphic Brand'].replace({'Intel':'0','NVIDIA':'1','RTX':'2','Unknown':'3','AMD':'4','Qualcomm':'5'})

appended_df['Graphic Brand'].unique()

appended_df

"""> ## __Color__"""

appended_df['Color'].unique()

appended_df['Color'].value_counts()

appended_df['Color'] = appended_df['Color'].replace({
    'Unknown': 0,
    'Black': 1,
    'White': 2,
    'Pike Silver': 3,
    'Blue': 4,
    'Silver': 5,
    'Natural Silver': 6,
    'Graphite': 7,
    'Natural silver': 6,  # Handling case sensitivity
    'Warm Gold': 8,
    'Pike Silver Aluminum': 9,
    'Grey': 10,
    'Sky Color': 11,
    'Storm Grey': 12,
    'Arctic Grey': 13,
    'Platinum Silver': 14
})

appended_df

"""> ## __Screen Resolution__"""

appended_df['Screen Resolution'].unique()

appended_df['Screen Resolution'].value_counts()

import pandas as pd

# Define default height and scaling factor
DEFAULT_HEIGHT = 1080
SCALING_FACTOR = 100  # Example: 100 pixels per mm

# Define realistic limits for resolutions
MIN_RESOLUTION = 100  # Minimum width and height in pixels
MAX_RESOLUTION = 10000  # Maximum width and height in pixels

def process_resolution(entry):
    if entry is None:
        return None

    # Attempt to convert screen resolution formats
    try:
        # Split by 'x' for resolution formats (e.g., 1920x1080)
        parts = entry.split('x')
        if len(parts) == 2:  # Resolution format
            width = int(float(parts[0]))
            height = int(float(parts[1]))
        elif len(parts) == 3:  # Physical measurements (e.g., 35.98x23.6x1.86)
            width = int(float(parts[0]) * SCALING_FACTOR)
            height = int(float(parts[1]) * SCALING_FACTOR)
        else:
            return None

        # Validate and scale dimensions if they exceed maximum
        if width > MAX_RESOLUTION or height > MAX_RESOLUTION:
            width //= 10
            height //= 10

        # Ensure dimensions are within realistic range
        if MIN_RESOLUTION <= width <= MAX_RESOLUTION and MIN_RESOLUTION <= height <= MAX_RESOLUTION:
            return f"{width}x{height}"

    except (ValueError, IndexError):
        pass

    # Handle aspect ratios (e.g., "16:9")
    try:
        if ':' in entry:
            ratio_parts = entry.split(':')
            width_ratio = int(ratio_parts[0])
            height_ratio = int(ratio_parts[1])
            width = int((width_ratio / height_ratio) * DEFAULT_HEIGHT)
            height = DEFAULT_HEIGHT

            # Validate and scale dimensions
            if MIN_RESOLUTION <= width <= MAX_RESOLUTION and MIN_RESOLUTION <= height <= MAX_RESOLUTION:
                return f"{width}x{height}"
    except (ValueError, IndexError):
        pass

    # If all parsing fails, return None
    return None

# Apply the processing function and directly update the 'Screen Resolution' column
appended_df['Screen Resolution'] = appended_df['Screen Resolution'].apply(process_resolution)

appended_df['Screen Resolution'].unique()

# Define the standard resolutions dictionary
standard_resolutions = {
    'HD': '1280x720',
    'Full HD': '1920x1080',
    '2K': '2560x1440',
    '4K': '3840x2160',
    'WXGA': '1366x768',
    # Add any other mappings as needed
}

def standardize_resolution(resolution):
    if pd.isna(resolution) or resolution is None or resolution == 'None':
        return '1366x768'  # Default for None or invalid values

    # Ensure resolution is treated as a string
    resolution_str = str(resolution)

    if resolution_str in standard_resolutions:
        return standard_resolutions[resolution_str]

    try:
        width, height = map(int, resolution_str.split('x'))
    except ValueError:
        return '1366x768'  # Return default for invalid formats

    # Define ranges for standard resolutions
    if (width >= 1920 and height >= 1080) and (width < 2560 and height < 1440):
        return '1920x1080'
    elif (width >= 2560 and height >= 1440) and (width < 3840 and height < 2160):
        return '2560x1440'
    elif (width >= 3840 and height >= 2160):
        return '3840x2160'
    elif (width < 1280 or height < 720):
        return '1280x720'
    elif (width < 1366 or height < 768):
        return '1366x768'
    else:
        return '1366x768'  # Default to '1366x768' for out of range values

# Apply the standardization function directly to the 'Screen Resolution' column
appended_df['Screen Resolution'] = appended_df['Screen Resolution'].apply(standardize_resolution)

# Display the updated DataFrame
print(appended_df['Screen Resolution'].unique())

appended_df['Screen Resolution'] = appended_df['Screen Resolution'].replace({
    '1280x720': 0,
    '1366x768': 1,
    '1920x1080': 2,
    '2560x1440': 3,
    '3840x2160': 4,

})

appended_df

appended_df['Screen Resolution'].value_counts()

"""+ # Examine The OutLiers

> ## __Price__
"""

appended_df['Price'].value_counts()

appended_df['Price'].describe()

"""> ## __Brand__"""

appended_df['Brand'].describe()

appended_df['Brand'].value_counts()

appended_df['Brand'].unique()

appended_df['Brand'].value_counts().plot(kind='bar')

"""> ## __Processor Generation__"""

appended_df['Processor Generation'].describe()

appended_df['Processor Generation'].value_counts()

appended_df['Processor Generation'].unique()

appended_df['Processor Generation'].value_counts().plot(kind='bar')

"""> ## __Processor Type__"""

appended_df['Processor Type'].describe()

appended_df['Processor Type'].value_counts()

appended_df['Processor Type'].unique()

appended_df['Processor Type'].value_counts().plot(kind='bar')

"""> ## __Processor Speed__"""

appended_df['Processor Speed'].describe()

appended_df['Processor Speed'].value_counts()

appended_df['Processor Speed'].unique()

appended_df['Processor Speed'].value_counts().plot(kind='bar')

"""> ## __Installed RAM__"""

appended_df['Installed RAM'].describe()

appended_df['Installed RAM'].value_counts()

appended_df['Installed RAM'].unique()

appended_df['Processor Speed'].value_counts().plot(kind='bar')

"""> ## __SSD__"""

appended_df['SSD'].describe()

appended_df['SSD'].value_counts()

appended_df['SSD'].unique()

appended_df['SSD'].value_counts().plot(kind='bar')

"""> ## __Graphic Brand__"""

appended_df['Graphic Brand'].describe()

appended_df['Graphic Brand'].value_counts()

appended_df['Graphic Brand'].value_counts().plot(kind='bar',figsize=(10,5))

"""> ## __Graphic Memory__"""

appended_df['Graphic Memory'].describe()

appended_df['Graphic Memory'].unique()

appended_df['Graphic Memory'].value_counts()

appended_df['Graphic Memory'].value_counts().plot(kind='bar')

"""> ## __Screen Resolution__"""

appended_df['Screen Resolution'].describe()

appended_df['Screen Resolution'].value_counts()

appended_df['Screen Resolution'].value_counts().plot(kind='bar',figsize=(10,5))

"""> ## __TouchScreen__"""

appended_df['TouchScreen'].describe()

appended_df['TouchScreen'].value_counts()

appended_df['TouchScreen'].unique()

appended_df['TouchScreen'].value_counts().plot(kind='bar')

"""> ## __Color__"""

appended_df['Color'].describe()

appended_df['Color'].value_counts()

appended_df['Color'].unique()

appended_df['Color'].value_counts().plot(kind='bar')

"""> ## __Weight__"""

appended_df['Weight'].describe()

appended_df['Weight'].value_counts()

appended_df['Weight'].value_counts().plot(kind='bar',figsize=(15,5))

"""> ## __Finger Print Reader__"""

appended_df['Finger Print Reader'].describe()

appended_df['Finger Print Reader'].value_counts()

appended_df['Finger Print Reader'].unique()

appended_df['Finger Print Reader'].value_counts().plot(kind='bar')

"""> ## __Backlit keyboard__"""

appended_df['Backlit keyboard'].describe()

appended_df['Backlit keyboard'].value_counts()

appended_df['Backlit keyboard'].unique()

appended_df['Backlit keyboard'].value_counts().plot(kind='bar')

"""> ## __LAN__"""

appended_df['LAN'].describe()

appended_df['LAN'].value_counts()

appended_df['LAN'].unique()

appended_df['LAN'].value_counts().plot(kind='bar')

"""> # Check outliers"""

numeric_df = appended_df.select_dtypes(include='number').dropna()

plt.figure(figsize=(15, 10))

num_columns = numeric_df.shape[1]
num_rows = (num_columns + 2) // 3  # Adjust based on your layout
fig, axes = plt.subplots(num_rows, 3, figsize=(15, num_rows * 4))

axes = axes.flatten()

for ax, column in zip(axes, numeric_df.columns):
    sns.histplot(numeric_df[column], bins=20, kde=True, color='skyblue', edgecolor='black', ax=ax)
    ax.set_title(f'Histogram of {column}')
    ax.set_xlabel(column)
    ax.set_ylabel('Frequency')

# Hide any unused axes
for ax in axes[num_columns:]:
    ax.set_visible(False)

plt.tight_layout()
plt.show()

"""> ##  __|--  Fixing outliers  --|__"""

# Prepare numeric DataFrame
numeric_df = appended_df.select_dtypes(include='number').dropna()

# Set up a figure to compare before and after outlier removal
fig, axes = plt.subplots(2, len(numeric_df.columns), figsize=(30, 15), constrained_layout=True)

# Plot "Before Outlier Removal"
for i, column in enumerate(numeric_df.columns):
    sns.boxplot(y=appended_df[column], color='lightblue', ax=axes[0, i])
    axes[0, i].set_title(f'Before: {column}')
    axes[0, i].set_ylabel(column)

# Apply IQR outlier removal
for column in numeric_df.columns:
    Q1 = numeric_df[column].quantile(0.25)
    Q3 = numeric_df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    numeric_df[column] = numeric_df[column].clip(lower=lower_bound, upper=upper_bound)

# Plot "After Outlier Removal"
for i, column in enumerate(numeric_df.columns):
    sns.boxplot(y=numeric_df[column], color='lightgreen', ax=axes[1, i])
    axes[1, i].set_title(f'After: {column}')
    axes[1, i].set_ylabel(column)

# Add overarching titles
fig.suptitle('Box Plots Before and After Outlier Removal', fontsize=16)
plt.show()

appended_df.head(5)

"""### __Applying Scaleing then fit predict, train test, linear regression model__"""

from sklearn.tree import DecisionTreeRegressor

X = appended_df.drop(columns=['Price'])
y = appended_df['Price']

tree = DecisionTreeRegressor()
tree.fit(X,y)

p_value = np.array([['1','5','1','5.1','8','256','2','350','5','1','1','5.40','1','1','1']])

ypred = tree.predict(p_value)
ypred